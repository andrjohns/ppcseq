bind_rows(
ppcSeq::counts %>%
inner_join(
(.) %>%
arrange(PValue) %>%
distinct(symbol) %>%
tail(n=2000)
)
) %>%
mutate(value = value %>% as.integer) %>%
mutate(is_significant = FDR < FDR_threshold) %>%
ppc_seq(
formula = ~ Label,
significance_column = PValue,
do_check_column = is_significant,
value_column = value
)
res_2
res_2 %>% filter(`tot deleterious outliers` > 0)
res_2 %>% unnest()
res_2 %>% unnest(`sample wise data`)
debugonce(ppc_seq)
res_1 %>%
select(symbol, `sample wise data`) %>%
unnest %>%
select(symbol, sample, `generated quantities`) %>%
unnest %>%
filter(`.draw` == 1) %>%
select(-`.chain`, -`.iteration`, -`.draw`) %>%
rename(value = `.value`) %>%
left_join( ppcSeq::counts %>% select(-value) %>% distinct()	) %>%
# Add negative controls
bind_rows(
ppcSeq::counts %>%
inner_join(
(.) %>%
arrange(PValue) %>%
distinct(symbol) %>%
tail(n=2000)
)
) %>%
mutate(value = value %>% as.integer) %>%
mutate(is_significant = FDR < FDR_threshold) %>%
ppc_seq(
formula = ~ Label,
significance_column = PValue,
do_check_column = is_significant,
value_column = value
)
debugonce(ppc_seq)
ppcSeq::counts %>%
mutate(is_significant = FDR < FDR_threshold) %>%
ppc_seq(
formula = ~ Label,
significance_column = PValue,
do_check_column = is_significant,
value_column = value,
save_generated_quantities = T
)
my_df
check_column
my_df %>% filter(!!do_check_column)
my_df %>% filter(!!do_check_column) %>% distinct(S, G)
my_df %>% filter(!!do_check_column) %>% distinct(S, G) %>% nrow
error_rate %>%
divide_by( (my_df %>% filter(!!do_check_column) %>% distinct(S, G) %>% nrow) ) %>%
multiply_by(2)
res_1 =
ppcSeq::counts %>%
mutate(is_significant = FDR < FDR_threshold) %>%
ppc_seq(
formula = ~ Label,
significance_column = PValue,
do_check_column = is_significant,
value_column = value,
save_generated_quantities = T
)
0.1/100
0.1/100/21
1/100/21
percent_false_positive_genes = "1%"
percent_false_positive_genes %>% gsub("%$", "", .) %>% as.numeric
"1" %>% gsub("%$", "", .) %>% as.numeric
"1a" %>% gsub("%$", "", .) %>% as.numeric
"a" %>% gsub("%$", "", .) %>% as.numeric
library(tidyverse)
library(magrittr)
library(ppcSeq)
FDR_threshold = 0.1
res_1 =
ppcSeq::counts %>%
mutate(is_significant = FDR < FDR_threshold) %>%
ppc_seq(
formula = ~ Label,
significance_column = PValue,
do_check_column = is_significant,
value_column = value,
save_generated_quantities = T,
percent_false_positive_genes = "5%"
)
library(tidyverse)
library(magrittr)
library(ppcSeq)
FDR_threshold = 0.1
res_1 =
ppcSeq::counts %>%
mutate(is_significant = FDR < FDR_threshold) %>%
ppc_seq(
formula = ~ Label,
significance_column = PValue,
do_check_column = is_significant,
value_column = value,
save_generated_quantities = T,
percent_false_positive_genes = "5%"
)
1
library(tidyverse)
library(magrittr)
library(ppcSeq)
FDR_threshold = 0.1
res_1 =
ppcSeq::counts %>%
mutate(is_significant = FDR < FDR_threshold) %>%
ppc_seq(
formula = ~ Label,
significance_column = PValue,
do_check_column = is_significant,
value_column = value,
save_generated_quantities = T,
percent_false_positive_genes = "5%"
)
res_1
ppcSeq::counts %>%
mutate(is_significant = FDR < 0.01)
ppcSeq::counts %>%
filter( FDR < 0.01)
ppcSeq::counts %>%
filter( FDR < 0.01) %>% distinct(symbol)
counts.ppc =
ppcSeq::counts %>%
mutate(is_significant = FDR < 0.01) %>%
ppc_seq(
formula = ~ Label,
significance_column = PValue,
do_check_column = is_significant,
value_column = value,
percent_false_positive_genes = "5%"
)
traceback()
debugonce(ppc_seq)
counts.ppc =
ppcSeq::counts %>%
mutate(is_significant = FDR < 0.01) %>%
ppc_seq(
formula = ~ Label,
significance_column = PValue,
do_check_column = is_significant,
value_column = value,
percent_false_positive_genes = "5%"
)
# Columns of counts to be ignored from the inference
to_exclude =
res_discovery %>%
filter(`.variable` == "counts_rng") %>%
filter(`deleterious outliers`) %>%
distinct(S, G, .lower, .upper)
how_namy_to_exclude = to_exclude %>% nrow
truncation_values =
res_discovery %>%
filter(`.variable` == "counts_rng") %>%
distinct(S, G, .lower, .upper) %>%
mutate(
`.lower` = `.lower` %>% as.integer,
`.upper` = `.upper` %>% as.integer
)
prior_from_discovery =
res_discovery %>%
filter(`.variable` != "counts_rng") %>%
select(`.variable`, S, G, mean, sd)
inits_fx =
function () {
pars =
res_discovery %>%
filter(`.variable` != "counts_rng") %>%
distinct(`.variable`) %>%
pull(1)
foreach(par = pars,	.final = function(x) setNames(x, pars)) %do% {
res_discovery %>%
filter(`.variable` == par) %>%
mutate(init = rnorm(n(),mean, sd)) %>%
mutate(init = 0) %>%
select(`.variable`, S, G, init) %>%
pull(init)
}
}
res_test =
my_df %>%
do_inference(
formula,
!!sample_column ,
!!gene_column ,
!!value_column ,
!!significance_column ,
!!do_check_column,
full_bayes,
C,
X,
lambda_mu_mu,
cores,
exposure_rate_multiplier,
intercept_shift_scale,
additional_parameters_to_save,
adj_prob_theshold = pfpg / 100 / (my_df %>% distinct(!!sample_column) %>% nrow), # * 2 because we just test one side of the distribution
to_exclude = to_exclude,
save_generated_quantities = save_generated_quantities,
truncation_compensation = 0.7352941
)
pfpg / 100 / (my_df %>% distinct(!!sample_column) %>% nrow)
pfpg
debugonce(do_inference)
res_test =
my_df %>%
do_inference(
formula,
!!sample_column ,
!!gene_column ,
!!value_column ,
!!significance_column ,
!!do_check_column,
full_bayes,
C,
X,
lambda_mu_mu,
cores,
exposure_rate_multiplier,
intercept_shift_scale,
additional_parameters_to_save,
adj_prob_theshold = pfpg / 100 / (my_df %>% distinct(!!sample_column) %>% nrow), # * 2 because we just test one side of the distribution
to_exclude = to_exclude,
save_generated_quantities = save_generated_quantities,
truncation_compensation = 0.7352941
)
sample_column = enquo(sample_column)
gene_column = enquo(gene_column)
value_column = enquo(value_column)
significance_column = enquo(significance_column)
do_check_column = enquo(do_check_column)
how_many_to_check =
my_df %>%
filter(!!do_check_column) %>%
distinct(!!gene_column) %>%
nrow
# Calculate the needed posterior draws
how_many_posterior_draws =  5 %>% divide_by(adj_prob_theshold) %>% max(500)
chains =
foreach(cc = 2:min(cores, 6), .combine = bind_rows) %do%
{ tibble(chains = cc, tot = how_many_posterior_draws / cc + 150 * cc )  } %>%
filter(tot == tot %>% min) %>%
pull(chains)
my_cores = cores %>% divide_by(chains) %>% floor
shards = my_cores
counts_MPI =
my_df %>%
select(!!gene_column, !!sample_column, !!value_column, S, G) %>%
format_for_MPI(shards, !!sample_column)
G = counts_MPI %>% distinct(G) %>% nrow()
S = counts_MPI %>% distinct(!!sample_column) %>% nrow()
N = counts_MPI %>% distinct(idx_MPI, !!value_column, `read count MPI row`) %>%  count(idx_MPI) %>% summarise(max(n)) %>% pull(1)
M = counts_MPI %>% distinct(start, idx_MPI) %>% count(idx_MPI) %>% pull(n) %>% max
G_per_shard = counts_MPI %>% distinct(!!gene_column, idx_MPI) %>% count(idx_MPI) %>% pull(n) %>% as.array
n_shards = min(shards, counts_MPI %>% distinct(idx_MPI) %>% nrow)
G_per_shard_idx = c(0, counts_MPI %>% distinct(!!gene_column, idx_MPI) %>% count(idx_MPI) %>% pull(n) %>% cumsum)
counts =
counts_MPI %>%
distinct(idx_MPI, !!value_column, `read count MPI row`)  %>%
spread(idx_MPI,  !!value_column) %>%
select(-`read count MPI row`) %>%
replace(is.na(.), 0 %>% as.integer) %>%
as_matrix() %>% t
sample_idx =
counts_MPI %>%
distinct(idx_MPI, S, `read count MPI row`)  %>%
spread(idx_MPI, S) %>%
select(-`read count MPI row`) %>%
replace(is.na(.), 0 %>% as.integer) %>%
as_matrix() %>% t
symbol_end =
counts_MPI %>%
distinct(idx_MPI, end, `symbol MPI row`)  %>%
spread(idx_MPI, end) %>%
bind_rows( (.) %>% head(n=1) %>%  mutate_all(function(x) {0}) ) %>%
arrange(`symbol MPI row`) %>%
select(-`symbol MPI row`) %>%
replace(is.na(.), 0 %>% as.integer) %>%
as_matrix() %>% t
G_ind =
counts_MPI %>%
distinct(idx_MPI, G, `symbol MPI row`)  %>%
spread(idx_MPI, G) %>%
arrange(`symbol MPI row`) %>%
select(-`symbol MPI row`) %>%
replace(is.na(.), 0 %>% as.integer) %>%
as_matrix() %>% t
to_exclude_MPI =
switch(
to_exclude %>% nrow %>% `>` (0) %>% `!` %>% sum(1), # If there are genes to exclude
foreach(s = 1:shards, .combine=full_join) %do% {
counts_MPI %>%
inner_join(to_exclude, by=c("S", "G")) %>%
filter(idx_MPI == s) %>%
distinct(idx_MPI, `read count MPI row`) %>%
rowid_to_column %>%
spread(idx_MPI, `read count MPI row`)
} %>%
# Add length array to the first row for indexing in MPI
{
bind_rows(
(.) %>% map(function(x) x %>% is.na %>% `!` %>% as.numeric %>% sum) %>% unlist,
(.)
)
} %>%
select(-rowid) %>%
replace(is.na(.), 0 %>% as.integer) %>%
as_matrix() %>% t,
matrix(rep(0,shards))
)
counts_package =
# Dimensions data sets
rep(c(M, N, S), shards) %>%
matrix(nrow = shards, byrow = T) %>%
cbind(G_per_shard) %>%
cbind(symbol_end) %>%
cbind(sample_idx) %>%
cbind(counts) %>%
cbind(to_exclude_MPI)
rep(c(M, N, S), shards) %>%
matrix(nrow = shards, byrow = T) %>%
cbind(G_per_shard)
rep(c(M, N, S), shards) %>%
matrix(nrow = shards, byrow = T) %>%
cbind(G_per_shard) %>%
cbind(symbol_end) %>%
cbind(sample_idx)
sample_idx
symbol_end
rep(c(M, N, S), shards) %>%
matrix(nrow = shards, byrow = T) %>%
cbind(G_per_shard) %>%
cbind(symbol_end) %>%
cbind(sample_idx) %>%
cbind(counts)
to_exclude_MPI
shards
foreach(s = 1:shards, .combine=full_join) %do% {
counts_MPI %>%
inner_join(to_exclude, by=c("S", "G")) %>%
filter(idx_MPI == s) %>%
distinct(idx_MPI, `read count MPI row`) %>%
rowid_to_column %>%
spread(idx_MPI, `read count MPI row`)
}
1:shards
counts_MPI %>%
inner_join(to_exclude, by=c("S", "G"))
foreach(s = 1:shards, .combine=full_join) %do% {
counts_MPI %>%
inner_join(to_exclude, by=c("S", "G")) %>%
filter(idx_MPI == s) %>%
distinct(idx_MPI, `read count MPI row`) %>%
rowid_to_column %>%
spread(idx_MPI, `read count MPI row`)
}
s=4
counts_MPI %>%
inner_join(to_exclude, by=c("S", "G")) %>%
filter(idx_MPI == s) %>%
distinct(idx_MPI, `read count MPI row`) %>%
rowid_to_column %>%
spread(idx_MPI, `read count MPI row`)
tibble(rowid = 1, !!s = NA)
tibble(rowid = 1, !!as.symbol(s) = NA)
tibble(rowid = 1, as.symbol(s) = NA)
tibble(rowid = 1) %>% mutate(!!as.symbol(s) := NA)
tibble(rowid = 1, !!as.symbol(s) := NA)
foreach(s = 1:shards, .combine=full_join) %do% {
counts_MPI %>%
inner_join(to_exclude, by=c("S", "G")) %>%
filter(idx_MPI == s) %>%
distinct(idx_MPI, `read count MPI row`) %>%
rowid_to_column %>%
spread(idx_MPI, `read count MPI row`) %>%
# Add shards missing from outliers
{
if((.) %>% nrow == 0) tibble(rowid = 1, !!as.symbol(s) := NA)
else (.)
}
}
to_exclude_MPI =
switch(
to_exclude %>% nrow %>% `>` (0) %>% `!` %>% sum(1), # If there are genes to exclude
foreach(s = 1:shards, .combine=full_join) %do% {
counts_MPI %>%
inner_join(to_exclude, by=c("S", "G")) %>%
filter(idx_MPI == s) %>%
distinct(idx_MPI, `read count MPI row`) %>%
rowid_to_column %>%
spread(idx_MPI, `read count MPI row`) %>%
# Add shards missing from outliers
{
if((.) %>% nrow == 0) tibble(rowid = 1, !!as.symbol(s) := NA)
else (.)
}
} %>%
# Add length array to the first row for indexing in MPI
{
bind_rows(
(.) %>% map(function(x) x %>% is.na %>% `!` %>% as.numeric %>% sum) %>% unlist,
(.)
)
} %>%
select(-rowid) %>%
replace(is.na(.), 0 %>% as.integer) %>%
as_matrix() %>% t,
matrix(rep(0,shards))
)
to_exclude_MPI
foreach(s = 1:shards, .combine=full_join) %do% {
counts_MPI %>%
inner_join(to_exclude, by=c("S", "G")) %>%
filter(idx_MPI == s) %>%
distinct(idx_MPI, `read count MPI row`) %>%
rowid_to_column %>%
spread(idx_MPI, `read count MPI row`) %>%
# Add shards missing from outliers
{
if((.) %>% nrow == 0) tibble(rowid = 1, !!as.symbol(s) := NA)
else (.)
}
} %>%
# Add length array to the first row for indexing in MPI
{
bind_rows(
(.) %>% map(function(x) x %>% is.na %>% `!` %>% as.numeric %>% sum) %>% unlist,
(.)
)
}
counts_package =
# Dimensions data sets
rep(c(M, N, S), shards) %>%
matrix(nrow = shards, byrow = T) %>%
cbind(G_per_shard) %>%
cbind(symbol_end) %>%
cbind(sample_idx) %>%
cbind(counts) %>%
cbind(to_exclude_MPI)
to_exclude_MPI
counts_package =
# Dimensions data sets
rep(c(M, N, S), shards) %>%
matrix(nrow = shards, byrow = T) %>%
cbind(G_per_shard) %>%
cbind(symbol_end) %>%
cbind(sample_idx) %>%
cbind(counts) %>%
cbind(to_exclude_MPI)
CP = ncol(counts_package)
Sys.setenv("STAN_NUM_THREADS" = my_cores)
Sys.time() %>% print
fit =
switch(
full_bayes %>% `!` %>% as.integer %>% sum(1),
sampling(
stanmodels$negBinomial_MPI, #pcc_seq_model, #
chains=chains, cores=chains,
iter=(how_many_posterior_draws/chains) %>% ceiling %>% sum(150),
warmup=150,
save_warmup = FALSE,
init = inits_fx
#, pars=c("counts_rng", "exposure_rate", additional_parameters_to_save)
),
vb(
stanmodels$negBinomial_MPI, #pcc_seq_model, #
output_samples=how_many_posterior_draws,
iter = 50000,
tol_rel_obj=0.005
#, pars=c("counts_rng", "exposure_rate", additional_parameters_to_save)
)
)
1
counts.ppc =
ppcSeq::counts %>%
mutate(is_significant = FDR < 0.01) %>%
de(
formula = ~ Label,
significance_column = PValue,
do_check_column = is_significant,
value_column = value,
percent_false_positive_genes = "5%"
)
ppcSeq::counts
debugonce(ppc_seq)
counts.ppc =
ppcSeq::counts %>%
mutate(is_significant = FDR < 0.01) %>%
de(
formula = ~ Label,
significance_column = PValue,
do_check_column = is_significant,
value_column = value,
percent_false_positive_genes = "5%"
)
1
